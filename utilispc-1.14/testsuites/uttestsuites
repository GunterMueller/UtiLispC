'chapter1
((lambda (a b c) (list a b c)) 'x 'y 'z)
((lambda (a b (c)) (list a b c)) 'x 'y)
((lambda (a b (c)) (list a b c)) 'x 'y 'z)
((lambda (a b (c 0)) (list a b c)) 'x 'y)
((lambda (a b (c 0)) (list a b c)) 'x 'y 'z)
((lambda (a b (c (print "default value is used for c.") 0)) (list a b c)) 'x 'y)
((lambda (a b (c (cons a b))) (list a b c)) 'x 'y 'z)
;((lambda (a b (c (cons a b))) (list a b c)) 'x 'y)
'chapter2
(symbolp 'foo)
(symbolp '(foo . bar))
(symbolp 1023)
(consp 'foo)
(consp '(foo . bar))
(consp 1023)
(listp 'foo)
(listp '(foo . bar))
(listp 1023)
(listp "(a b c)")
(listp ())
(atom 'foo)
(atom 1023)
(atom '(foo . bar))
(atom "string")
(atom obvector)
;(atom terminal-input)
(fixp 'foo)
(fixp '(foo . bar))
(fixp 1023)
;(fixp 1.23)

;(fixp (expt 2 30))
;(floatp 1.23)
;(floatp 1.23^3)
;(floatp -1.23)
(numberp 1023)
;(numberp (expt 2 30))
(numberp 1.23)
;(numberp 1.23^3)
(numberp "1023")
(stringp "1023")
(stringp 'symbol)
(stringp "")
(vectorp 'foo)
(vectorp obvector)
(vectorp '(1 2 3))
;(streamp terminal-input)
;(streamp "terminal-input")
(codep 'car)
(codep 'foo)
'chapter3
(eval '(cons 'foo 'bar)))
;(apply 'cons '(foo bar))
;(funcall 'cons 'foo 'bar)
(setq cons 'plus)
;(funcall cons 1 2)
(cons 1 2)
(quote x)
(setq x (quote (cons 1 2)))
x
(setq x '(cons 1 2))
(setq x 1)
(setq y 2)
(setq x (prog1 y (setq y x)))
x
y
(and)
(or)
;(defun fn0 (x) (set x (list 'quote x)))
;(mapc '(a b c d e f g) 'fn0)
;a
;d
;g
;(mapc '(a b c d e f g) (function (lambda (x) (set x x))))
;a
;d
;g
(mapcar '(foo bar baz quux mum goo)
  (function (lambda (x) (selectq x (foo 1) (bar 2) ((baz quux mum) 3) (t 4)))))
'chapter4
((lambda (x) (cond ((null x) nil) (t (append (reverse (cdr x)) (cons (car x) nil))))) '((a b) (b c) (c a)))
(defun rev2 (y z) (cond ((null y) z) (t (rev2 (cdr y) (cons (car y) z)))))
((lambda (x) (rev2 x nil)) '((a b) (b c) (c a)))
((lambda (x) (prog (y z) (setq y x) a (cond ((null y) (return z))) (setq z (cons (car y) z)) (setq y (cdr y)) (go a))) '((a b) (b c) (c a)))
;mapping
'map
(setq l nil)
(map '(a b c) (function (lambda (x) (setq l (cons (ncons x) l)))))
l
(setq l nil)
'mapc
(mapc '(a b c) (function (lambda (x) (setq l (cons (ncons x) l)))))
l
(setq l nil)
'maplist
(maplist '(a b c) (function (lambda (x) (setq l (cons (ncons x) l)))))
l
(setq l nil)
'mapcar
(mapcar '(a b c) (function (lambda (x) (setq l (cons (ncons x) l)))))
l
(setq l nil)
;(mapcon '(a b c) (function (lambda (x) (setq l (cons (ncons x) l)))))
l
(setq l nil)
'mapcan
;(mapcan '(a b c) (function (lambda (x) (setq l (cons (ncons x) l)))))
l
'chapter5
(setq crlist '(cr car cdr caar cadr cdar cddr caaar caadr cadar caddr cdaar
cdadr cddar cdddr caaaar caaadr caadar caaddr cadaar cadadr caddar cadddr
cdaaar cdaadr cdadar cdaddr cddaar cddadr cdddar cddddr))
(cr '(x))
(car '((x)))
(cdr '(y x))
(caar '(((x))))
(cadr '(y (x)))
(cdar '((y x)))
(cddr '(y y x))
(caaar '((((x)))))
(caadr '(y ((x))))
(cadar '((y (x))))
(caddr '(y y (x)))
(cdaar '(((y x))))
(cdadr '(y (y x)))
(cddar '((y y x)))
(cdddr '(y y y x))
(caaaar '(((((x))))))
(caaadr '(y (((x)))))
(caadar '((y ((x)))))
(caaddr '(y y ((x))))
(cadaar '(((y (x)))))
(cadadr '(y (y (x))))
(caddar '((y y (x))))
(cadddr '(y y y (x)))
(cdaaar '((((y x)))))
(cdaadr '(y ((y x))))
(cdadar '((y (y x))))
(cdaddr '(y y (y x)))
(cddaar '(((y y x))))
(cddadr '(y (y y x)))
(cdddar '((y y y x)))
(cddddr '(y y y y x))
(last crlist)
(length crlist)
(first crlist)
(second crlist)
(third crlist)
(fourth crlist)
(fifth crlist)
(sixth crlist)
(seventh crlist)
(setq numlist '(0 1 2 3 4 5 6 7))
(setq l nil)
(defun fn1 (x) (setq l (cons (nth (- 7 x) numlist) l)))
(defun fn1 (x) (setq l (cons (nth (- 7 x) numlist)l)))
(mapc numlist 'fn1)
l
(setq l nil)
(defun fn1 (x) (setq l (cons (nthcdr (- 7 x) numlist)l)))
(mapc numlist 'fn1)
l
(maplist '(a b c d) (function reverse))
(mapcar '(a b c d) (function (lambda (a) (cons a nil))))
;(filter '(1 5 7 2 6 3) (function (lambda (x) (> x 3))))
(defun diff (y x) (cond ((atom y) (cond ((eq y x) 'one) (t 'zero)))
((eq (car y) 'plus) (cons 'plus (maplist (cdr y)
(function (lambda (z) (diff (car z) x))))))
((eq (car y) 'times)
(cons 'plus (maplist (cdr y)
(function (lambda (z) (cons 'times (maplist (cdr y)
(function (lambda (w) (cond ((not (equal z w)) (car w))
(t (diff (car w) x))))))))))))))
(diff '(times x (plus x a) y) 'x)
(defun trans (x) (cond ((null (car x)) nil)
(t (cons (mapcar x 'car) (trans (mapcar x 'cdr))))))
(trans '((a00 a01 a02) (a10 a11 a12)))
'chapter7
(0= 0)
(0= 1)
(0< 0)
(0< 1)
;(0< -1)
(0> 0)
(0> 1)
;(0> -1)
(= 3 3)
(= 1 2)
(# 3 3)
(# 1 2)
(<> 3 3)
(<> 1 2)
(< 1 2 3)
(< 2)
(< 1 2 2)
(> 3 2 2)
(> 2)
(> 3 2 1)
(<= 1 2 1)
(<= 2)
(<= 1 2 2)
(>= 3 2 2)
(>= 2)
(>= 3 2 3)
(>= 1 2 3)
(+)
(- 5)
(- 5 3 1)
(* 1 2 3 4)
(*)
;(// 100 12)
(1+ 7)
(1- 8)
(\ 100 12)
(^ 2 5)
(^ 2 16)
(logor 1 2 4 8)
(logor)
(logand)
(logand 15 7 3 1)
(logxor 15 7 3 1)
(logxor)
(logshift 15 2)
(logshift 15 (- 2))
'chapter8
(character "a")
(character "alice")
(character 'alice)
(character "")
(setq geb "goedel escher bach")
(string-length geb)
(string-length "string-length")
;(string-length 'alice)
(string-equal geb "goedel escher bach")
(string-lessp "bar" "foo")
(string-lessp "stringp" (string 'string))
;(substring geb 7 13)
;(string-append "mac" "in" "tosh")
;(string-append 'foo 'bar 'cat)
;(setq foo (symbol "newsym"))
;(eq 'newsym foo)
;(setq foo (intern foo))
;(eq 'newsym foo)
;(setq byte (make-string 1))
;(sset byte 0 255)
;(bset byte 0 nil)
;(sref byte 0)
'(defun prime (x) (comment "count the number of primes from 1 to 2x")
(lets ((size (// (+ x 7) 8)) (lambda (make-string size)) (count 1) (prime)
(c (character 255)) (i 0) (k))
(loop (and (= i size) (exit)) (sset lambda i c) (setq i (1+ i)))
(setq i 1)
(loop (and (= i x) (exit))
(cond ((bref lambda i) (setq prime (+ i i 1))
(setq k(+ i prime))
(loop (cond ((< k x) (bset lambda k nil) (setq k (+ k prime)))
(t (exit))))
(setq count (1+ count))))
(setq i (1+ i))) count))
;(prime 5)
;(prime 50)
;(prime 500)
'chapter9
(setq a1 (vector 4))
(vset a1 0 'foo)
(vset a1 1 'bar)
;(fill-vector a1 '(foo bar (a b c) "abc"))
(vref a1 0)
(vref a1 1)
(vector-length obvector)
(vref obvector (\ (hash 'sort) (vector-length obvector)))
(\ (hash 'sort) (vector-length obvector))
(\ (hash 'macro) (vector-length obvector))
end

